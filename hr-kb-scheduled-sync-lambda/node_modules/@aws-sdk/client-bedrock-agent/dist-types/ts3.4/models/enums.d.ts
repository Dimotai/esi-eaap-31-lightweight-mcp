export declare const CustomControlMethod: {
  readonly RETURN_CONTROL: "RETURN_CONTROL";
};
export type CustomControlMethod =
  (typeof CustomControlMethod)[keyof typeof CustomControlMethod];
export declare const ActionGroupState: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type ActionGroupState =
  (typeof ActionGroupState)[keyof typeof ActionGroupState];
export declare const Type: {
  readonly ARRAY: "array";
  readonly BOOLEAN: "boolean";
  readonly INTEGER: "integer";
  readonly NUMBER: "number";
  readonly STRING: "string";
};
export type Type = (typeof Type)[keyof typeof Type];
export declare const RequireConfirmation: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type RequireConfirmation =
  (typeof RequireConfirmation)[keyof typeof RequireConfirmation];
export declare const ActionGroupSignature: {
  readonly AMAZON_CODEINTERPRETER: "AMAZON.CodeInterpreter";
  readonly AMAZON_USERINPUT: "AMAZON.UserInput";
  readonly ANTHROPIC_BASH: "ANTHROPIC.Bash";
  readonly ANTHROPIC_COMPUTER: "ANTHROPIC.Computer";
  readonly ANTHROPIC_TEXTEDITOR: "ANTHROPIC.TextEditor";
};
export type ActionGroupSignature =
  (typeof ActionGroupSignature)[keyof typeof ActionGroupSignature];
export declare const AgentCollaboration: {
  readonly DISABLED: "DISABLED";
  readonly SUPERVISOR: "SUPERVISOR";
  readonly SUPERVISOR_ROUTER: "SUPERVISOR_ROUTER";
};
export type AgentCollaboration =
  (typeof AgentCollaboration)[keyof typeof AgentCollaboration];
export declare const AgentStatus: {
  readonly CREATING: "CREATING";
  readonly DELETING: "DELETING";
  readonly FAILED: "FAILED";
  readonly NOT_PREPARED: "NOT_PREPARED";
  readonly PREPARED: "PREPARED";
  readonly PREPARING: "PREPARING";
  readonly UPDATING: "UPDATING";
  readonly VERSIONING: "VERSIONING";
};
export type AgentStatus = (typeof AgentStatus)[keyof typeof AgentStatus];
export declare const MemoryType: {
  readonly SESSION_SUMMARY: "SESSION_SUMMARY";
};
export type MemoryType = (typeof MemoryType)[keyof typeof MemoryType];
export declare const OrchestrationType: {
  readonly CUSTOM_ORCHESTRATION: "CUSTOM_ORCHESTRATION";
  readonly DEFAULT: "DEFAULT";
};
export type OrchestrationType =
  (typeof OrchestrationType)[keyof typeof OrchestrationType];
export declare const CreationMode: {
  readonly DEFAULT: "DEFAULT";
  readonly OVERRIDDEN: "OVERRIDDEN";
};
export type CreationMode = (typeof CreationMode)[keyof typeof CreationMode];
export declare const PromptState: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type PromptState = (typeof PromptState)[keyof typeof PromptState];
export declare const PromptType: {
  readonly KNOWLEDGE_BASE_RESPONSE_GENERATION: "KNOWLEDGE_BASE_RESPONSE_GENERATION";
  readonly MEMORY_SUMMARIZATION: "MEMORY_SUMMARIZATION";
  readonly ORCHESTRATION: "ORCHESTRATION";
  readonly POST_PROCESSING: "POST_PROCESSING";
  readonly PRE_PROCESSING: "PRE_PROCESSING";
};
export type PromptType = (typeof PromptType)[keyof typeof PromptType];
export declare const AgentAliasStatus: {
  readonly CREATING: "CREATING";
  readonly DELETING: "DELETING";
  readonly DISSOCIATED: "DISSOCIATED";
  readonly FAILED: "FAILED";
  readonly PREPARED: "PREPARED";
  readonly UPDATING: "UPDATING";
};
export type AgentAliasStatus =
  (typeof AgentAliasStatus)[keyof typeof AgentAliasStatus];
export declare const AliasInvocationState: {
  readonly ACCEPT_INVOCATIONS: "ACCEPT_INVOCATIONS";
  readonly REJECT_INVOCATIONS: "REJECT_INVOCATIONS";
};
export type AliasInvocationState =
  (typeof AliasInvocationState)[keyof typeof AliasInvocationState];
export declare const RelayConversationHistory: {
  readonly DISABLED: "DISABLED";
  readonly TO_COLLABORATOR: "TO_COLLABORATOR";
};
export type RelayConversationHistory =
  (typeof RelayConversationHistory)[keyof typeof RelayConversationHistory];
export declare const KnowledgeBaseState: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type KnowledgeBaseState =
  (typeof KnowledgeBaseState)[keyof typeof KnowledgeBaseState];
export declare const DataDeletionPolicy: {
  readonly DELETE: "DELETE";
  readonly RETAIN: "RETAIN";
};
export type DataDeletionPolicy =
  (typeof DataDeletionPolicy)[keyof typeof DataDeletionPolicy];
export declare const CrawlFilterConfigurationType: {
  readonly PATTERN: "PATTERN";
};
export type CrawlFilterConfigurationType =
  (typeof CrawlFilterConfigurationType)[keyof typeof CrawlFilterConfigurationType];
export declare const ConfluenceAuthType: {
  readonly BASIC: "BASIC";
  readonly OAUTH2_CLIENT_CREDENTIALS: "OAUTH2_CLIENT_CREDENTIALS";
};
export type ConfluenceAuthType =
  (typeof ConfluenceAuthType)[keyof typeof ConfluenceAuthType];
export declare const ConfluenceHostType: {
  readonly SAAS: "SAAS";
};
export type ConfluenceHostType =
  (typeof ConfluenceHostType)[keyof typeof ConfluenceHostType];
export declare const SalesforceAuthType: {
  readonly OAUTH2_CLIENT_CREDENTIALS: "OAUTH2_CLIENT_CREDENTIALS";
};
export type SalesforceAuthType =
  (typeof SalesforceAuthType)[keyof typeof SalesforceAuthType];
export declare const SharePointAuthType: {
  readonly OAUTH2_CLIENT_CREDENTIALS: "OAUTH2_CLIENT_CREDENTIALS";
  readonly OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS: "OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS";
};
export type SharePointAuthType =
  (typeof SharePointAuthType)[keyof typeof SharePointAuthType];
export declare const SharePointHostType: {
  readonly ONLINE: "ONLINE";
};
export type SharePointHostType =
  (typeof SharePointHostType)[keyof typeof SharePointHostType];
export declare const DataSourceType: {
  readonly CONFLUENCE: "CONFLUENCE";
  readonly CUSTOM: "CUSTOM";
  readonly REDSHIFT_METADATA: "REDSHIFT_METADATA";
  readonly S3: "S3";
  readonly SALESFORCE: "SALESFORCE";
  readonly SHAREPOINT: "SHAREPOINT";
  readonly WEB: "WEB";
};
export type DataSourceType =
  (typeof DataSourceType)[keyof typeof DataSourceType];
export declare const WebScopeType: {
  readonly HOST_ONLY: "HOST_ONLY";
  readonly SUBDOMAINS: "SUBDOMAINS";
};
export type WebScopeType = (typeof WebScopeType)[keyof typeof WebScopeType];
export declare const ChunkingStrategy: {
  readonly FIXED_SIZE: "FIXED_SIZE";
  readonly HIERARCHICAL: "HIERARCHICAL";
  readonly NONE: "NONE";
  readonly SEMANTIC: "SEMANTIC";
};
export type ChunkingStrategy =
  (typeof ChunkingStrategy)[keyof typeof ChunkingStrategy];
export declare const EnrichmentStrategyMethod: {
  readonly CHUNK_ENTITY_EXTRACTION: "CHUNK_ENTITY_EXTRACTION";
};
export type EnrichmentStrategyMethod =
  (typeof EnrichmentStrategyMethod)[keyof typeof EnrichmentStrategyMethod];
export declare const ContextEnrichmentType: {
  readonly BEDROCK_FOUNDATION_MODEL: "BEDROCK_FOUNDATION_MODEL";
};
export type ContextEnrichmentType =
  (typeof ContextEnrichmentType)[keyof typeof ContextEnrichmentType];
export declare const StepType: {
  readonly POST_CHUNKING: "POST_CHUNKING";
};
export type StepType = (typeof StepType)[keyof typeof StepType];
export declare const ParsingModality: {
  readonly MULTIMODAL: "MULTIMODAL";
};
export type ParsingModality =
  (typeof ParsingModality)[keyof typeof ParsingModality];
export declare const ParsingStrategy: {
  readonly BEDROCK_DATA_AUTOMATION: "BEDROCK_DATA_AUTOMATION";
  readonly BEDROCK_FOUNDATION_MODEL: "BEDROCK_FOUNDATION_MODEL";
};
export type ParsingStrategy =
  (typeof ParsingStrategy)[keyof typeof ParsingStrategy];
export declare const DataSourceStatus: {
  readonly AVAILABLE: "AVAILABLE";
  readonly DELETE_UNSUCCESSFUL: "DELETE_UNSUCCESSFUL";
  readonly DELETING: "DELETING";
};
export type DataSourceStatus =
  (typeof DataSourceStatus)[keyof typeof DataSourceStatus];
export declare const FlowConnectionType: {
  readonly CONDITIONAL: "Conditional";
  readonly DATA: "Data";
};
export type FlowConnectionType =
  (typeof FlowConnectionType)[keyof typeof FlowConnectionType];
export declare const SupportedLanguages: {
  readonly PYTHON_3: "Python_3";
};
export type SupportedLanguages =
  (typeof SupportedLanguages)[keyof typeof SupportedLanguages];
export declare const PerformanceConfigLatency: {
  readonly OPTIMIZED: "optimized";
  readonly STANDARD: "standard";
};
export type PerformanceConfigLatency =
  (typeof PerformanceConfigLatency)[keyof typeof PerformanceConfigLatency];
export declare const RerankingMetadataSelectionMode: {
  readonly ALL: "ALL";
  readonly SELECTIVE: "SELECTIVE";
};
export type RerankingMetadataSelectionMode =
  (typeof RerankingMetadataSelectionMode)[keyof typeof RerankingMetadataSelectionMode];
export declare const VectorSearchRerankingConfigurationType: {
  readonly BEDROCK_RERANKING_MODEL: "BEDROCK_RERANKING_MODEL";
};
export type VectorSearchRerankingConfigurationType =
  (typeof VectorSearchRerankingConfigurationType)[keyof typeof VectorSearchRerankingConfigurationType];
export declare const CachePointType: {
  readonly DEFAULT: "default";
};
export type CachePointType =
  (typeof CachePointType)[keyof typeof CachePointType];
export declare const ConversationRole: {
  readonly ASSISTANT: "assistant";
  readonly USER: "user";
};
export type ConversationRole =
  (typeof ConversationRole)[keyof typeof ConversationRole];
export declare const PromptTemplateType: {
  readonly CHAT: "CHAT";
  readonly TEXT: "TEXT";
};
export type PromptTemplateType =
  (typeof PromptTemplateType)[keyof typeof PromptTemplateType];
export declare const FlowNodeInputCategory: {
  readonly EXIT_LOOP: "ExitLoop";
  readonly LOOP_CONDITION: "LoopCondition";
  readonly RETURN_VALUE_TO_LOOP_START: "ReturnValueToLoopStart";
};
export type FlowNodeInputCategory =
  (typeof FlowNodeInputCategory)[keyof typeof FlowNodeInputCategory];
export declare const FlowNodeIODataType: {
  readonly ARRAY: "Array";
  readonly BOOLEAN: "Boolean";
  readonly NUMBER: "Number";
  readonly OBJECT: "Object";
  readonly STRING: "String";
};
export type FlowNodeIODataType =
  (typeof FlowNodeIODataType)[keyof typeof FlowNodeIODataType];
export declare const FlowNodeType: {
  readonly AGENT: "Agent";
  readonly COLLECTOR: "Collector";
  readonly CONDITION: "Condition";
  readonly INLINE_CODE: "InlineCode";
  readonly INPUT: "Input";
  readonly ITERATOR: "Iterator";
  readonly KNOWLEDGE_BASE: "KnowledgeBase";
  readonly LAMBDA_FUNCTION: "LambdaFunction";
  readonly LEX: "Lex";
  readonly LOOP: "Loop";
  readonly LOOP_CONTROLLER: "LoopController";
  readonly LOOP_INPUT: "LoopInput";
  readonly OUTPUT: "Output";
  readonly PROMPT: "Prompt";
  readonly RETRIEVAL: "Retrieval";
  readonly STORAGE: "Storage";
};
export type FlowNodeType = (typeof FlowNodeType)[keyof typeof FlowNodeType];
export declare const FlowStatus: {
  readonly FAILED: "Failed";
  readonly NOT_PREPARED: "NotPrepared";
  readonly PREPARED: "Prepared";
  readonly PREPARING: "Preparing";
};
export type FlowStatus = (typeof FlowStatus)[keyof typeof FlowStatus];
export declare const ConcurrencyType: {
  readonly AUTOMATIC: "Automatic";
  readonly MANUAL: "Manual";
};
export type ConcurrencyType =
  (typeof ConcurrencyType)[keyof typeof ConcurrencyType];
export declare const IncompatibleLoopNodeType: {
  readonly COLLECTOR: "Collector";
  readonly CONDITION: "Condition";
  readonly INPUT: "Input";
  readonly ITERATOR: "Iterator";
};
export type IncompatibleLoopNodeType =
  (typeof IncompatibleLoopNodeType)[keyof typeof IncompatibleLoopNodeType];
export declare const FlowValidationSeverity: {
  readonly ERROR: "Error";
  readonly WARNING: "Warning";
};
export type FlowValidationSeverity =
  (typeof FlowValidationSeverity)[keyof typeof FlowValidationSeverity];
export declare const FlowValidationType: {
  readonly CYCLIC_CONNECTION: "CyclicConnection";
  readonly DUPLICATE_CONDITION_EXPRESSION: "DuplicateConditionExpression";
  readonly DUPLICATE_CONNECTIONS: "DuplicateConnections";
  readonly INCOMPATIBLE_CONNECTION_DATA_TYPE: "IncompatibleConnectionDataType";
  readonly INVALID_LOOP_BOUNDARY: "InvalidLoopBoundary";
  readonly LOOP_INCOMPATIBLE_NODE_TYPE: "LoopIncompatibleNodeType";
  readonly MALFORMED_CONDITION_EXPRESSION: "MalformedConditionExpression";
  readonly MALFORMED_NODE_INPUT_EXPRESSION: "MalformedNodeInputExpression";
  readonly MISMATCHED_NODE_INPUT_TYPE: "MismatchedNodeInputType";
  readonly MISMATCHED_NODE_OUTPUT_TYPE: "MismatchedNodeOutputType";
  readonly MISSING_CONNECTION_CONFIGURATION: "MissingConnectionConfiguration";
  readonly MISSING_DEFAULT_CONDITION: "MissingDefaultCondition";
  readonly MISSING_ENDING_NODES: "MissingEndingNodes";
  readonly MISSING_LOOP_CONTROLLER_NODE: "MissingLoopControllerNode";
  readonly MISSING_LOOP_INPUT_NODE: "MissingLoopInputNode";
  readonly MISSING_NODE_CONFIGURATION: "MissingNodeConfiguration";
  readonly MISSING_NODE_INPUT: "MissingNodeInput";
  readonly MISSING_NODE_OUTPUT: "MissingNodeOutput";
  readonly MISSING_STARTING_NODES: "MissingStartingNodes";
  readonly MULTIPLE_LOOP_CONTROLLER_NODES: "MultipleLoopControllerNodes";
  readonly MULTIPLE_LOOP_INPUT_NODES: "MultipleLoopInputNodes";
  readonly MULTIPLE_NODE_INPUT_CONNECTIONS: "MultipleNodeInputConnections";
  readonly UNFULFILLED_NODE_INPUT: "UnfulfilledNodeInput";
  readonly UNKNOWN_CONNECTION_CONDITION: "UnknownConnectionCondition";
  readonly UNKNOWN_CONNECTION_SOURCE: "UnknownConnectionSource";
  readonly UNKNOWN_CONNECTION_SOURCE_OUTPUT: "UnknownConnectionSourceOutput";
  readonly UNKNOWN_CONNECTION_TARGET: "UnknownConnectionTarget";
  readonly UNKNOWN_CONNECTION_TARGET_INPUT: "UnknownConnectionTargetInput";
  readonly UNKNOWN_NODE_INPUT: "UnknownNodeInput";
  readonly UNKNOWN_NODE_OUTPUT: "UnknownNodeOutput";
  readonly UNREACHABLE_NODE: "UnreachableNode";
  readonly UNSATISFIED_CONNECTION_CONDITIONS: "UnsatisfiedConnectionConditions";
  readonly UNSPECIFIED: "Unspecified";
};
export type FlowValidationType =
  (typeof FlowValidationType)[keyof typeof FlowValidationType];
export declare const IngestionJobStatus: {
  readonly COMPLETE: "COMPLETE";
  readonly FAILED: "FAILED";
  readonly IN_PROGRESS: "IN_PROGRESS";
  readonly STARTING: "STARTING";
  readonly STOPPED: "STOPPED";
  readonly STOPPING: "STOPPING";
};
export type IngestionJobStatus =
  (typeof IngestionJobStatus)[keyof typeof IngestionJobStatus];
export declare const IngestionJobFilterAttribute: {
  readonly STATUS: "STATUS";
};
export type IngestionJobFilterAttribute =
  (typeof IngestionJobFilterAttribute)[keyof typeof IngestionJobFilterAttribute];
export declare const IngestionJobFilterOperator: {
  readonly EQ: "EQ";
};
export type IngestionJobFilterOperator =
  (typeof IngestionJobFilterOperator)[keyof typeof IngestionJobFilterOperator];
export declare const IngestionJobSortByAttribute: {
  readonly STARTED_AT: "STARTED_AT";
  readonly STATUS: "STATUS";
};
export type IngestionJobSortByAttribute =
  (typeof IngestionJobSortByAttribute)[keyof typeof IngestionJobSortByAttribute];
export declare const SortOrder: {
  readonly ASCENDING: "ASCENDING";
  readonly DESCENDING: "DESCENDING";
};
export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];
export declare const ContentDataSourceType: {
  readonly CUSTOM: "CUSTOM";
  readonly S3: "S3";
};
export type ContentDataSourceType =
  (typeof ContentDataSourceType)[keyof typeof ContentDataSourceType];
export declare const DocumentStatus: {
  readonly DELETE_IN_PROGRESS: "DELETE_IN_PROGRESS";
  readonly DELETING: "DELETING";
  readonly FAILED: "FAILED";
  readonly IGNORED: "IGNORED";
  readonly INDEXED: "INDEXED";
  readonly IN_PROGRESS: "IN_PROGRESS";
  readonly METADATA_PARTIALLY_INDEXED: "METADATA_PARTIALLY_INDEXED";
  readonly METADATA_UPDATE_FAILED: "METADATA_UPDATE_FAILED";
  readonly NOT_FOUND: "NOT_FOUND";
  readonly PARTIALLY_INDEXED: "PARTIALLY_INDEXED";
  readonly PENDING: "PENDING";
  readonly STARTING: "STARTING";
};
export type DocumentStatus =
  (typeof DocumentStatus)[keyof typeof DocumentStatus];
export declare const InlineContentType: {
  readonly BYTE: "BYTE";
  readonly TEXT: "TEXT";
};
export type InlineContentType =
  (typeof InlineContentType)[keyof typeof InlineContentType];
export declare const CustomSourceType: {
  readonly IN_LINE: "IN_LINE";
  readonly S3_LOCATION: "S3_LOCATION";
};
export type CustomSourceType =
  (typeof CustomSourceType)[keyof typeof CustomSourceType];
export declare const MetadataValueType: {
  readonly BOOLEAN: "BOOLEAN";
  readonly NUMBER: "NUMBER";
  readonly STRING: "STRING";
  readonly STRING_LIST: "STRING_LIST";
};
export type MetadataValueType =
  (typeof MetadataValueType)[keyof typeof MetadataValueType];
export declare const MetadataSourceType: {
  readonly IN_LINE_ATTRIBUTE: "IN_LINE_ATTRIBUTE";
  readonly S3_LOCATION: "S3_LOCATION";
};
export type MetadataSourceType =
  (typeof MetadataSourceType)[keyof typeof MetadataSourceType];
export declare const RedshiftProvisionedAuthType: {
  readonly IAM: "IAM";
  readonly USERNAME: "USERNAME";
  readonly USERNAME_PASSWORD: "USERNAME_PASSWORD";
};
export type RedshiftProvisionedAuthType =
  (typeof RedshiftProvisionedAuthType)[keyof typeof RedshiftProvisionedAuthType];
export declare const RedshiftServerlessAuthType: {
  readonly IAM: "IAM";
  readonly USERNAME_PASSWORD: "USERNAME_PASSWORD";
};
export type RedshiftServerlessAuthType =
  (typeof RedshiftServerlessAuthType)[keyof typeof RedshiftServerlessAuthType];
export declare const RedshiftQueryEngineType: {
  readonly PROVISIONED: "PROVISIONED";
  readonly SERVERLESS: "SERVERLESS";
};
export type RedshiftQueryEngineType =
  (typeof RedshiftQueryEngineType)[keyof typeof RedshiftQueryEngineType];
export declare const IncludeExclude: {
  readonly EXCLUDE: "EXCLUDE";
  readonly INCLUDE: "INCLUDE";
};
export type IncludeExclude =
  (typeof IncludeExclude)[keyof typeof IncludeExclude];
export declare const RedshiftQueryEngineStorageType: {
  readonly AWS_DATA_CATALOG: "AWS_DATA_CATALOG";
  readonly REDSHIFT: "REDSHIFT";
};
export type RedshiftQueryEngineStorageType =
  (typeof RedshiftQueryEngineStorageType)[keyof typeof RedshiftQueryEngineStorageType];
export declare const QueryEngineType: {
  readonly REDSHIFT: "REDSHIFT";
};
export type QueryEngineType =
  (typeof QueryEngineType)[keyof typeof QueryEngineType];
export declare const KnowledgeBaseType: {
  readonly KENDRA: "KENDRA";
  readonly SQL: "SQL";
  readonly VECTOR: "VECTOR";
};
export type KnowledgeBaseType =
  (typeof KnowledgeBaseType)[keyof typeof KnowledgeBaseType];
export declare const EmbeddingDataType: {
  readonly BINARY: "BINARY";
  readonly FLOAT32: "FLOAT32";
};
export type EmbeddingDataType =
  (typeof EmbeddingDataType)[keyof typeof EmbeddingDataType];
export declare const SupplementalDataStorageLocationType: {
  readonly S3: "S3";
};
export type SupplementalDataStorageLocationType =
  (typeof SupplementalDataStorageLocationType)[keyof typeof SupplementalDataStorageLocationType];
export declare const KnowledgeBaseStorageType: {
  readonly MONGO_DB_ATLAS: "MONGO_DB_ATLAS";
  readonly NEPTUNE_ANALYTICS: "NEPTUNE_ANALYTICS";
  readonly OPENSEARCH_MANAGED_CLUSTER: "OPENSEARCH_MANAGED_CLUSTER";
  readonly OPENSEARCH_SERVERLESS: "OPENSEARCH_SERVERLESS";
  readonly PINECONE: "PINECONE";
  readonly RDS: "RDS";
  readonly REDIS_ENTERPRISE_CLOUD: "REDIS_ENTERPRISE_CLOUD";
  readonly S3_VECTORS: "S3_VECTORS";
};
export type KnowledgeBaseStorageType =
  (typeof KnowledgeBaseStorageType)[keyof typeof KnowledgeBaseStorageType];
export declare const KnowledgeBaseStatus: {
  readonly ACTIVE: "ACTIVE";
  readonly CREATING: "CREATING";
  readonly DELETE_UNSUCCESSFUL: "DELETE_UNSUCCESSFUL";
  readonly DELETING: "DELETING";
  readonly FAILED: "FAILED";
  readonly UPDATING: "UPDATING";
};
export type KnowledgeBaseStatus =
  (typeof KnowledgeBaseStatus)[keyof typeof KnowledgeBaseStatus];
